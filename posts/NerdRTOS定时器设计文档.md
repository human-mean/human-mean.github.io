---
title: NerdRTOS 定时器设计文档
date: 2026-02-03
draft: false
showToc: true
TocOpen: true
---

# NerdRTOS 定时器子系统设计文档

## 1. 概述

NerdRTOS 的定时器子系统旨在为内核及应用程序提供精确的时间管理服务。该系统设计了两种工作模式——**Tick 模式（传统节拍）**与 **Tickless 模式（动态时钟）**，以适应从资源受限的微控制器到对功耗敏感的现代 SoC 等不同应用场景。

系统的核心不仅仅是简单的链表管理，而是采用了**红黑树（Red-Black Tree）**作为定时器容器，显著提升了在大量定时器并发场景下的插入与查找效率。

## 2. 核心数据结构

定时器子系统的设计围绕 `nd_timer_t` 结构体展开，采用了非侵入式的节点设计，直接嵌入内核的通用数据结构。

### 2.1 定时器控制块 (`nd_timer_t`)

定义于 `include/nd_def.h`，该结构体包含以下关键成员：

* **`struct rb_node node`**：红黑树节点，用于将定时器挂载到内核的全局定时器树上。
* **`nd_uint64_t expire_time`**：绝对到期时间。内核统一将用户设置的相对超时时间转换为系统启动以来的绝对时间戳（Ticks 或微秒），以此作为红黑树排序的键值（Key）。
* **`nd_timer_type_t type`**：定时器类型，支持单次触发（`ND_TIMER_TYPE_ONE_SHOT`）和周期触发（`ND_TIMER_TYPE_PERIODIC`）。
* **回调机制**：包含函数指针 `callback` 和参数 `arg`，在定时器到期时执行。

### 2.2 全局容器 (`rbtree_root`)

内核维护一个静态全局变量 `rbtree_root`（定义于 `kernel/nd_timer.c`）。所有活动的定时器都驻留在这棵红黑树中。
使用红黑树的优势在于：

* **查找最优**：获取最早到期的定时器（即树的最左节点 `rb_first`）的时间复杂度极低。
* **操作稳定**：插入和删除定时器的时间复杂度为 ，避免了传统双向链表在长列表下的遍历开销。

## 3. 运行模式详解

系统通过宏 `ND_CFG_TICKLESS` 进行编译期配置，决定底层时钟驱动机制。

### 3.1 Tick 模式 

当 `ND_CFG_TICKLESS` 为 0 时，系统工作在固定节拍模式。

* **时基驱动**：依赖硬件的周期性中断（如 SysTick）。在 `arch/arm/m33/port.c` 中，Systick 被配置为以 `ND_TICKS_PER_SEC` 的频率产生中断。
* **处理流程**：
每次 Systick 中断触发 `isr_systick`，进而调用 `nd_timer_process()`。内核通过 `nd_hw_tick_get_current()` 获取当前 Tick 计数，并检查红黑树最左节点是否到期。
* **特点**：实现简单，但存在空闲时的无效中断开销。

### 3.2 Tickless 模式 

当 `ND_CFG_TICKLESS` 为 1 时，系统启用高精度动态定时模式。

* **时基驱动**：依赖硬件的单次触发定时器（One-shot Timer）。例如在 RP2040/Pico2 上，使用 `hardware_alarm` 实现。
* **按需中断**：
系统不再有固定的“滴答”声。每当有新定时器插入或当前定时器处理完毕时，内核会计算距离下一个最近到期事件的时间差，并调用 `nd_hw_hrtimer_set_expire()` 精确编程硬件。
* **优势**：
1. **高精度**：时间分辨率取决于硬件定时器（通常为微秒级），而非 Tick 频率。
2. **低功耗**：无任务时硬件定时器可被挂起或设置到极远的未来，允许 CPU 深度睡眠。



## 4. 关键机制实现

### 4.1 定时器插入与重编程

在 `nd_timer_start` -> `timer_insert` 流程中：

1. 内核计算 `expire_time`（当前时间 + 用户超时）。
2. 将节点插入红黑树。
3. **Tickless 特有逻辑**：插入后，内核会检查新节点是否成为了“最左节点”（即最早到期的任务）。如果是，说明这个新任务比之前安排的所有任务都要急，内核必须立即调用 `nd_hw_hrtimer_set_expire` 更新硬件定时器的触发时间。

### 4.2 级联过期处理

`nd_timer_process` 负责处理到期事件。由于可能存在多个定时器在同一时刻到期，或者处理回调时耗时导致后续定时器过期，该函数采用了一个 `for(;;)` 循环：

1. 获取红黑树最左节点。
2. 比较其 `expire_time` 与当前硬件时间。
3. 如果已到期，将其从树中移除（`rb_erase`），执行回调。
4. 如果是周期性定时器，计算下一周期时间并重新插入树中。
5. 重复上述步骤，直到最左节点的时间晚于当前时间。
6. 最后，将硬件定时器设置为红黑树中剩余的最早到期时间。

### 4.3 并发保护

定时器子系统涉及全局共享数据（红黑树），因此所有核心操作（初始化、启动、停止、处理）均通过 `nd_kernel_lock()` 和 `nd_kernel_unlock()` 临界区保护，这通常通过屏蔽全局中断实现。

## 5. 硬件抽象层接口 (HAL)

为了实现上述逻辑，BSP 层需实现 `include/nd_hw.h` 定义的以下接口：

| 接口名称 | 描述 | 适用模式 |
| --- | --- | --- |
| `nd_hw_tick_init` | 初始化周期性节拍中断 | Tick |
| `nd_hw_tick_get_current` | 获取当前节拍计数 | Tick |
| `nd_hw_hrtimer_init` | 初始化高精度硬件定时器 | Tickless |
| `nd_hw_hrtimer_set_expire` | 设置下一次中断的绝对时间 | Tickless |
| `nd_hw_hrtimer_get_current` | 获取当前高精度时间戳（如 us） | Tickless |
| `nd_hw_hrtimer_trigger` | 软件强制触发定时器中断 | Tickless |

此设计确保了核心逻辑与硬件实现的解耦，便于移植到不同的架构（ARM Cortex-M, RISC-V 等）。