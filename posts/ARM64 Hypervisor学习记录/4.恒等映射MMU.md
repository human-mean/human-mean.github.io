---
title: 恒等映射MMU
date: 2026-02-03
draft: false
showToc: true
TocOpen: true
---
### 为什么需要**MMU**？
>裸机代码中CPU发送的地址直接发送到物理内存。但存在几个问题：
>- 所有代码都能访问所有地址，没有保护。
>- 若跑多个Guest OS,地址会存在冲突。
>- 没法控制某段内存是 cacheable 还是 device 类型

MMU就是在CPU和物理内存中充当了翻译：CPU发送虚拟地址（VA），MMU通过查表翻译成物理地址（PA），同时附带权限和属性的信息。MMU查的这个表就是**页表**。

#### **恒等映射**：
>恒等映射即虚拟地址=物理地址

先从恒等映射开始是因为：
- MMU 启用前后，PC 指针指向的地址必须在 MMU 启用后仍然有效，不然读取不到下一条指令。
- 代码段、栈、串口都用恒等映射，逻辑简单，容易调试。

#### 页表
假设有一个`uint64_t table[512]`,通过index，数组返回一个值。页表原理类似，MMU拿到一个虚拟地址，从里面找到几个bit当作index，从页表去查数组，得到结果。如果一级数组来覆盖整个48-bit地址空间，需要2^48，不现实。

所以需要用到**多级数组**。4KB garanule是一个四维数组查找：
- table_L0[i0] -> 指向table_L1
- table_L1[i1] -> 指向table_L2
- table_L2[i2] -> 指向table_L3
- table_L3[i3] -> 最终的物理页地址

<details>
<summary>为什么4kb的粒度是48bit？为什么是4级页表而不是3级页表？</summary>

1.4kb粒度意味着每一张页表的大小最多只能是4kb（4096字节）。
2.ARM64是64位系统，所以页表的每一个条目（指向下一级表的指针）必须是64bit（8字节）

一页最多只能寸512个条目：4096/8=512

索引需要9bit（2^9=512）

9(L1) + 9 (L2) + 9(L3) + 9(L4) +12(Offset) = 48bit 

为什么是四级页表：
三级页表为39bit,容量只有2^39=512G，这远远不够用。
四级页表为48bit，容量有2^48=256TB。

</details>

{{< admonition type="question" title="核心推导：为什么是 48-bit & 4级页表？" open=true >}}

**1. 基础限制**
* **页大小 (Page Size):** 4KB ($2^{12}$ Bytes)。
* **指针大小:** ARM64 是 64 位系统，每个页表项 (PTE) 需 8 Bytes ($64 \text{ bits}$)。

**2. 单级页表容量计算**
由于一页只有 4KB，所以一张页表能容纳的条目数为：
$$\frac{4096 \text{ Bytes}}{8 \text{ Bytes}} = 512 \text{ Entries} = 2^9$$
这意味着，每一级索引需要 **9 bits** ($2^9=512$)。

**3. 地址位宽推导 (4级页表)**
$$\underbrace{9}_{\text{L1}} + \underbrace{9}_{\text{L2}} + \underbrace{9}_{\text{L3}} + \underbrace{9}_{\text{L4}} + \underbrace{12}_{\text{Offset}} = \mathbf{48 \text{ bits}}$$

**4. 为什么不是 3 级？**
* **3级页表:** $9+9+9+12 = 39 \text{ bits}$。寻址范围 $2^{39} = 512 \text{ GB}$ (对于现代服务器内存不够)。
* **4级页表:** $48 \text{ bits}$。寻址范围 $2^{48} = 256 \text{ TB}$ (足够覆盖主流需求)。

{{< /admonition >}}