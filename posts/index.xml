<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on 嵌入式学习笔记</title><link>https://human-mean.github.io/posts/</link><description>Recent content in Posts on 嵌入式学习笔记</description><generator>Hugo -- 0.155.2</generator><language>zh-cn</language><lastBuildDate>Tue, 03 Feb 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://human-mean.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>ARM64启动流程</title><link>https://human-mean.github.io/posts/arm64-hypervisor%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.arm64%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Tue, 03 Feb 2026 00:00:00 +0000</pubDate><guid>https://human-mean.github.io/posts/arm64-hypervisor%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.arm64%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid><description>&lt;h2 id="starts-启动代码"&gt;start.S 启动代码&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;start.S是cpu上电运行的第一段代码,负责初始化硬件环境并且为程序运行做准备。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="设置栈指针"&gt;设置栈指针&lt;/h4&gt;
&lt;p&gt;c语言的函数调用栈来保存返回地址、局部变量和函数参数，进入c代码之前必须为栈指针（sp）设置一个有效值。栈从高地址向低地址生长，所以栈指针初始化为RAM的高地址边界。&lt;/p&gt;
&lt;h4 id="清空-bss-段"&gt;清空 BSS 段&lt;/h4&gt;
&lt;p&gt;BSS用于存储为初始化的全局和局部变量，如果不手动将BSS段清零，上电后的RAM内容会是不确定的随机值。&lt;/p&gt;
&lt;h4 id="bss-段的优化意义"&gt;BSS 段的优化意义&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;减小二进制文件大小&lt;/strong&gt;：未初始化的变量不占用文件空间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加快加载速度&lt;/strong&gt;：只需记录大小，运行时清零&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;统一初始化&lt;/strong&gt;：保证所有未初始化变量的初始值为零&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="bss段清零不能用memset"&gt;BSS段清零不能用&lt;code&gt;memset&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;memset&lt;/code&gt;是c库函数，其实现本身可能使用为初始化的全局变量，或需要已经初始化的栈，BSS清零前调用&lt;code&gt;memset&lt;/code&gt;会导致循环依赖。&lt;/p&gt;
&lt;h4 id="跳转到-main"&gt;跳转到 main&lt;/h4&gt;
&lt;p&gt;底层硬件初始化完成后将控制权交给c程序入口点&lt;code&gt;main&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="写代码"&gt;写代码&lt;/h2&gt;
&lt;h4 id="链接脚本"&gt;链接脚本&lt;/h4&gt;
&lt;p&gt;链接脚本用于告诉连接器代码和数据放在内寸的哪个位置。&lt;/p&gt;
&lt;p&gt;下面是最简单的链接脚本：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;ENTRY(_start) //ENTRY指定入口符号，也就是告诉链接脚本从哪里开始
SECTIONS{
. = 0x40000000;
.text : {
src/start.o(.text)
*(.text)
}
. = ALIGN(16); //ARM64要求栈指针必须16字节对齐，在定义栈或者数据段之前要对齐八字节。
_stack_top = . + 0x10000;
}
/*
‘.’ 是位置计数器，. = `0x40000000` 意思是从 0x40000000 开始放东西。
*/
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id="starts"&gt;start.S&lt;/h4&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;.global _start
_start:
ldr x0, =_stack_top
mov sp, x0
bl main
/*
传递栈顶地址给sp
*/
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id="为什么不能直接写mov-x0-_stack_top"&gt;为什么不能直接写&lt;code&gt;mov x0, _stack_top&lt;/code&gt;?&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;查阅数据手册可以知道，MOV指令立即数最大就是16位，无法通过一次指令表示&lt;code&gt;0x40010000&lt;/code&gt;这种任意地址&lt;/p&gt;</description></item><item><title>NerdRTOS 定时器设计文档</title><link>https://human-mean.github.io/posts/nerdrtos/nerdrtos%E5%AE%9A%E6%97%B6%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</link><pubDate>Tue, 03 Feb 2026 00:00:00 +0000</pubDate><guid>https://human-mean.github.io/posts/nerdrtos/nerdrtos%E5%AE%9A%E6%97%B6%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</guid><description>&lt;h1 id="nerdrtos-定时器子系统设计文档"&gt;NerdRTOS 定时器子系统设计文档&lt;/h1&gt;
&lt;h2 id="1-概述"&gt;1. 概述&lt;/h2&gt;
&lt;p&gt;NerdRTOS 的定时器子系统旨在为内核及应用程序提供精确的时间管理服务。该系统设计了两种工作模式——**Tick 模式（传统节拍）**与 &lt;strong&gt;Tickless 模式（动态时钟）&lt;/strong&gt;，以适应从资源受限的微控制器到对功耗敏感的现代 SoC 等不同应用场景。&lt;/p&gt;
&lt;p&gt;系统的核心不仅仅是简单的链表管理，而是采用了**红黑树（Red-Black Tree）**作为定时器容器，显著提升了在大量定时器并发场景下的插入与查找效率。&lt;/p&gt;
&lt;h2 id="2-核心数据结构"&gt;2. 核心数据结构&lt;/h2&gt;
&lt;p&gt;定时器子系统的设计围绕 &lt;code&gt;nd_timer_t&lt;/code&gt; 结构体展开，采用了非侵入式的节点设计，直接嵌入内核的通用数据结构。&lt;/p&gt;
&lt;h3 id="21-定时器控制块-nd_timer_t"&gt;2.1 定时器控制块 (&lt;code&gt;nd_timer_t&lt;/code&gt;)&lt;/h3&gt;
&lt;p&gt;定义于 &lt;code&gt;include/nd_def.h&lt;/code&gt;，该结构体包含以下关键成员：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;struct rb_node node&lt;/code&gt;&lt;/strong&gt;：红黑树节点，用于将定时器挂载到内核的全局定时器树上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;nd_uint64_t expire_time&lt;/code&gt;&lt;/strong&gt;：绝对到期时间。内核统一将用户设置的相对超时时间转换为系统启动以来的绝对时间戳（Ticks 或微秒），以此作为红黑树排序的键值（Key）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;nd_timer_type_t type&lt;/code&gt;&lt;/strong&gt;：定时器类型，支持单次触发（&lt;code&gt;ND_TIMER_TYPE_ONE_SHOT&lt;/code&gt;）和周期触发（&lt;code&gt;ND_TIMER_TYPE_PERIODIC&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回调机制&lt;/strong&gt;：包含函数指针 &lt;code&gt;callback&lt;/code&gt; 和参数 &lt;code&gt;arg&lt;/code&gt;，在定时器到期时执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="22-全局容器-rbtree_root"&gt;2.2 全局容器 (&lt;code&gt;rbtree_root&lt;/code&gt;)&lt;/h3&gt;
&lt;p&gt;内核维护一个静态全局变量 &lt;code&gt;rbtree_root&lt;/code&gt;（定义于 &lt;code&gt;kernel/nd_timer.c&lt;/code&gt;）。所有活动的定时器都驻留在这棵红黑树中。
使用红黑树的优势在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;查找最优&lt;/strong&gt;：获取最早到期的定时器（即树的最左节点 &lt;code&gt;rb_first&lt;/code&gt;）的时间复杂度极低。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作稳定&lt;/strong&gt;：插入和删除定时器的时间复杂度为 ，避免了传统双向链表在长列表下的遍历开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="3-运行模式详解"&gt;3. 运行模式详解&lt;/h2&gt;
&lt;p&gt;系统通过宏 &lt;code&gt;ND_CFG_TICKLESS&lt;/code&gt; 进行编译期配置，决定底层时钟驱动机制。&lt;/p&gt;
&lt;h3 id="31-tick-模式"&gt;3.1 Tick 模式&lt;/h3&gt;
&lt;p&gt;当 &lt;code&gt;ND_CFG_TICKLESS&lt;/code&gt; 为 0 时，系统工作在固定节拍模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;时基驱动&lt;/strong&gt;：依赖硬件的周期性中断（如 SysTick）。在 &lt;code&gt;arch/arm/m33/port.c&lt;/code&gt; 中，Systick 被配置为以 &lt;code&gt;ND_TICKS_PER_SEC&lt;/code&gt; 的频率产生中断。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理流程&lt;/strong&gt;：
每次 Systick 中断触发 &lt;code&gt;isr_systick&lt;/code&gt;，进而调用 &lt;code&gt;nd_timer_process()&lt;/code&gt;。内核通过 &lt;code&gt;nd_hw_tick_get_current()&lt;/code&gt; 获取当前 Tick 计数，并检查红黑树最左节点是否到期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：实现简单，但存在空闲时的无效中断开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="32-tickless-模式"&gt;3.2 Tickless 模式&lt;/h3&gt;
&lt;p&gt;当 &lt;code&gt;ND_CFG_TICKLESS&lt;/code&gt; 为 1 时，系统启用高精度动态定时模式。&lt;/p&gt;</description></item><item><title>哈希表</title><link>https://human-mean.github.io/posts/c%E8%AF%AD%E8%A8%80/%E5%93%88%E5%B8%8C%E8%A1%A8/</link><pubDate>Tue, 03 Feb 2026 00:00:00 +0000</pubDate><guid>https://human-mean.github.io/posts/c%E8%AF%AD%E8%A8%80/%E5%93%88%E5%B8%8C%E8%A1%A8/</guid><description>&lt;h3 id="哈希表是什么"&gt;哈希表是什么&lt;/h3&gt;
&lt;p&gt;哈希表通过建立键 &lt;code&gt;key&lt;/code&gt; 与值 &lt;code&gt;value&lt;/code&gt; 之间的映射，实现高效的元素查询，只需要输入一个&lt;code&gt;key&lt;/code&gt;就能获得对应值的value。　&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;哈希表与链表、数组的时间复杂度比较：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;数组&lt;/th&gt;
&lt;th&gt;链表&lt;/th&gt;
&lt;th&gt;哈希表&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;查找元素&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;添加元素&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除元素&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="哈希函数"&gt;哈希函数&lt;/h3&gt;
&lt;p&gt;一个&lt;strong&gt;把数据转换成数组下标&lt;/strong&gt;的规则，只有两个要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同样的输入，永远得到同样的输出&lt;/li&gt;
&lt;li&gt;输出范围在 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;size-1&lt;/code&gt; 之间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;输入一个key，我们可以通过哈希函数获得key值对应键值的存储位置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;哈希函数的计算步骤：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.通过一个哈希算法&lt;code&gt;hash()&lt;/code&gt;得到哈希值。
2.将哈希值的数组长度&lt;code&gt;capacity&lt;/code&gt;取模，从而获取对应的&lt;code&gt;index&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;index = hash(key) % capacity&lt;/code&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;因为哈希函数可能算出很大的数，但数组下标是有限的。取模可以把任意大的数压缩到 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;capacity-1&lt;/code&gt; 的范围内。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id="哈希冲突与扩容"&gt;哈希冲突与扩容&lt;/h3&gt;
&lt;p&gt;哈希函数的作用是将所有 &lt;code&gt;key&lt;/code&gt; 构成的输入空间映射到数组所有索引构成的输出空间，而输入空间往往远大于输出空间。因此&lt;strong&gt;理论上一定存在多个输入对应相同输出的情况&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;7 % 10 = 7
17 % 10 = 7
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;哈希表容量越大，输出相同的可能性就越低，通过&lt;em&gt;扩容哈希表&lt;/em&gt;可以减少&lt;em&gt;哈希冲突&lt;/em&gt;&lt;/p&gt;</description></item></channel></rss>