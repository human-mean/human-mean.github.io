<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>嵌入式学习笔记</title><link>https://human-mean.github.io/</link><description>Recent content on 嵌入式学习笔记</description><generator>Hugo -- 0.155.2</generator><language>zh-cn</language><lastBuildDate>Tue, 03 Feb 2026 00:00:00 +0000</lastBuildDate><atom:link href="https://human-mean.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>1.ARM64启动流程</title><link>https://human-mean.github.io/posts/arm64-hypervisor%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.arm64%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link><pubDate>Tue, 03 Feb 2026 00:00:00 +0000</pubDate><guid>https://human-mean.github.io/posts/arm64-hypervisor%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/1.arm64%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid><description>&lt;h2 id="starts-启动代码"&gt;start.S 启动代码&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;start.S是cpu上电运行的第一段代码,负责初始化硬件环境并且为程序运行做准备。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id="设置栈指针"&gt;设置栈指针&lt;/h4&gt;
&lt;p&gt;c语言的函数调用栈来保存返回地址、局部变量和函数参数，进入c代码之前必须为栈指针（sp）设置一个有效值。栈从高地址向低地址生长，所以栈指针初始化为RAM的高地址边界。&lt;/p&gt;
&lt;h4 id="清空-bss-段"&gt;清空 BSS 段&lt;/h4&gt;
&lt;p&gt;BSS用于存储为初始化的全局和局部变量，如果不手动将BSS段清零，上电后的RAM内容会是不确定的随机值。&lt;/p&gt;
&lt;h4 id="bss-段的优化意义"&gt;BSS 段的优化意义&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;减小二进制文件大小&lt;/strong&gt;：未初始化的变量不占用文件空间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;加快加载速度&lt;/strong&gt;：只需记录大小，运行时清零&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;统一初始化&lt;/strong&gt;：保证所有未初始化变量的初始值为零&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="bss段清零不能用memset"&gt;BSS段清零不能用&lt;code&gt;memset&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;memset&lt;/code&gt;是c库函数，其实现本身可能使用为初始化的全局变量，或需要已经初始化的栈，BSS清零前调用&lt;code&gt;memset&lt;/code&gt;会导致循环依赖。&lt;/p&gt;
&lt;h4 id="跳转到-main"&gt;跳转到 main&lt;/h4&gt;
&lt;p&gt;底层硬件初始化完成后将控制权交给c程序入口点&lt;code&gt;main&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id="写代码"&gt;写代码&lt;/h2&gt;
&lt;h4 id="链接脚本"&gt;链接脚本&lt;/h4&gt;
&lt;p&gt;链接脚本用于告诉连接器代码和数据放在内寸的哪个位置。&lt;/p&gt;
&lt;p&gt;下面是最简单的链接脚本：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;ENTRY(_start) //ENTRY指定入口符号，也就是告诉链接脚本从哪里开始
SECTIONS{
. = 0x40000000;
.text : {
src/start.o(.text)
*(.text)
}
. = ALIGN(16); //ARM64要求栈指针必须16字节对齐，在定义栈或者数据段之前要对齐八字节。
_stack_top = . + 0x10000;
}
/*
‘.’ 是位置计数器，. = `0x40000000` 意思是从 0x40000000 开始放东西。
*/
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id="starts"&gt;start.S&lt;/h4&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;.global _start
_start:
ldr x0, =_stack_top
mov sp, x0
bl main
/*
传递栈顶地址给sp
*/
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id="为什么不能直接写mov-x0-_stack_top"&gt;为什么不能直接写&lt;code&gt;mov x0, _stack_top&lt;/code&gt;?&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;查阅数据手册可以知道，MOV指令立即数最大就是16位，无法通过一次指令表示&lt;code&gt;0x40010000&lt;/code&gt;这种任意地址&lt;/p&gt;</description></item><item><title>2.打印hello world</title><link>https://human-mean.github.io/posts/arm64-hypervisor%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2.%E6%89%93%E5%8D%B0hello-world/</link><pubDate>Tue, 03 Feb 2026 00:00:00 +0000</pubDate><guid>https://human-mean.github.io/posts/arm64-hypervisor%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/2.%E6%89%93%E5%8D%B0hello-world/</guid><description>&lt;h2 id="阅读手册"&gt;阅读手册&lt;/h2&gt;
&lt;p&gt;我们需要打印helloworld，需要知道两个事：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.字符往哪里写 &lt;br&gt;
2.什么时候可以写&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为此我们需要找到&lt;code&gt;DR&lt;/code&gt;和&lt;code&gt;FR&lt;/code&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;寄存器&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;th&gt;为什么需要&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DR(Data Register)&lt;/td&gt;
&lt;td&gt;数据寄存器&lt;/td&gt;
&lt;td&gt;写入的字符从DR发出&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FR(Flag Register)&lt;/td&gt;
&lt;td&gt;状态寄存器&lt;/td&gt;
&lt;td&gt;得知缓冲区是否满了&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src="https://human-mean.github.io/posts/ARM64%20Hypervisor%e5%ad%a6%e4%b9%a0%e8%ae%b0%e5%bd%95/images/UARTDR.png" alt="" loading="lazy" /&gt;
&lt;strong&gt;DR寄存器的偏移量为0x000&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="https://human-mean.github.io/posts/ARM64%20Hypervisor%e5%ad%a6%e4%b9%a0%e8%ae%b0%e5%bd%95/images/UARTFR.png" alt="" loading="lazy" /&gt;
&lt;strong&gt;FR寄存器的偏移量为0x018&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来查找TXFF的位定位。
&lt;img src="https://human-mean.github.io/posts/ARM64%20Hypervisor%e5%ad%a6%e4%b9%a0%e8%ae%b0%e5%bd%95/images/UARTTXFF.png" alt="" loading="lazy" /&gt;
&lt;strong&gt;TXFF&lt;/strong&gt;是bit5&lt;/p&gt;
&lt;p&gt;知道了寄存器偏移量和位定位后开始写uart.h&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;#ifndef __UART_H__
#define __UART_H__
#define UART_BASE 0x09000000
#define UART_DR (UART_BASE + 0x000)
#define UART_FR (UART_BASE + 0x018)
#define UART_TXFF (1&amp;lt;&amp;lt;5)
#endif
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="uartc实现"&gt;uart.c实现&lt;/h2&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;void uart_putc(char c)
{
while(UART_FR &amp;amp; UART_TXFF); //判断缓冲区是否为满
UART_DR = c;
}
void uart_puts(char *s)
{
while (*s){
uart_putc(*s++);
}
}
&lt;/code&gt;&lt;/pre&gt;</description></item><item><title>3.实现异常向量表 + GDB 调试能力</title><link>https://human-mean.github.io/posts/arm64-hypervisor%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/3.%E5%AE%9E%E7%8E%B0%E5%BC%82%E5%B8%B8%E5%90%91%E9%87%8F%E8%A1%A8-+-gdb-%E8%B0%83%E8%AF%95%E8%83%BD%E5%8A%9B/</link><pubDate>Tue, 03 Feb 2026 00:00:00 +0000</pubDate><guid>https://human-mean.github.io/posts/arm64-hypervisor%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/3.%E5%AE%9E%E7%8E%B0%E5%BC%82%E5%B8%B8%E5%90%91%E9%87%8F%E8%A1%A8-+-gdb-%E8%B0%83%E8%AF%95%E8%83%BD%E5%8A%9B/</guid><description>&lt;blockquote&gt;
&lt;p&gt;虽然现在能够跑helloworld，但如果遇到错误（比如访问非法地址），CPU会挂死且没有提示，异常向量表可以让我们获取错误信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="阅读手册"&gt;阅读手册&lt;/h2&gt;
&lt;p&gt;找到手册《DDI0487_M_a_a_a-profile_architecture_reference_manual》
&lt;img src="https://human-mean.github.io/posts/ARM64%20Hypervisor%e5%ad%a6%e4%b9%a0%e8%ae%b0%e5%bd%95/images/exception_vector.png" alt="" loading="lazy" /&gt;
&lt;/p&gt;
&lt;h3 id="什么是异常"&gt;什么是异常&lt;/h3&gt;
&lt;p&gt;在CPU运行的时候，遇到被打断的事件就称作异常，这是一个技术术语，并不带贬义。CPU被打断后需要知道要跳去那哪里处理，向量表就是告诉cpu跳转去哪里的一张表。&lt;/p&gt;
&lt;h3 id="异常类型"&gt;异常类型&lt;/h3&gt;
&lt;p&gt;ARM64有&lt;strong&gt;4&lt;/strong&gt;种异常类型：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Synchronous&lt;/strong&gt;:代码主动触发，如执行非法指令，访问非法地址，调用&lt;code&gt;svc&lt;/code&gt;系统调用。叫作&lt;strong&gt;同步&lt;/strong&gt;是因为和正在执行的指令相关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;IRQ&lt;/strong&gt;:外部硬件中断，如定时器中断，串口中断。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;FIQ&lt;/strong&gt;:快速中断，比IRQ优先级更高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;SError&lt;/strong&gt;系统错误，比如外部内存总线出错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每个异常发生的时候，都需要区分&lt;strong&gt;状态&lt;/strong&gt;，ARM64按照两个维度区分：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1,异常来自当前EL还是更低的EL
2.异常发生的时候用的哪个栈指针&lt;/p&gt;
&lt;/blockquote&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;EL=Exception Level(异常级别)
ARM64把CPU运行权限分成4层，数字越大权限越高：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;EL0&lt;/strong&gt; — 用户程序（权限最低，不能碰硬件）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EL1&lt;/strong&gt; — OS 内核（管理内存、中断）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EL2&lt;/strong&gt; — Hypervisor（虚拟机监控器 ← 最终目标）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;EL3&lt;/strong&gt; — 安全固件（Secure Monitor，一般不碰）&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;这两个维度可以组合出四组情况，一共有四个入口，所以4组 * 4入口= 16入口，异常向量表有16个入口。&lt;/p&gt;</description></item><item><title>NerdRTOS 定时器设计文档</title><link>https://human-mean.github.io/posts/nerdrtos/nerdrtos%E5%AE%9A%E6%97%B6%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</link><pubDate>Tue, 03 Feb 2026 00:00:00 +0000</pubDate><guid>https://human-mean.github.io/posts/nerdrtos/nerdrtos%E5%AE%9A%E6%97%B6%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</guid><description>&lt;h1 id="nerdrtos-定时器子系统设计文档"&gt;NerdRTOS 定时器子系统设计文档&lt;/h1&gt;
&lt;h2 id="1-概述"&gt;1. 概述&lt;/h2&gt;
&lt;p&gt;NerdRTOS 的定时器子系统旨在为内核及应用程序提供精确的时间管理服务。该系统设计了两种工作模式——**Tick 模式（传统节拍）**与 &lt;strong&gt;Tickless 模式（动态时钟）&lt;/strong&gt;，以适应从资源受限的微控制器到对功耗敏感的现代 SoC 等不同应用场景。&lt;/p&gt;
&lt;p&gt;系统的核心不仅仅是简单的链表管理，而是采用了**红黑树（Red-Black Tree）**作为定时器容器，显著提升了在大量定时器并发场景下的插入与查找效率。&lt;/p&gt;
&lt;h2 id="2-核心数据结构"&gt;2. 核心数据结构&lt;/h2&gt;
&lt;p&gt;定时器子系统的设计围绕 &lt;code&gt;nd_timer_t&lt;/code&gt; 结构体展开，采用了非侵入式的节点设计，直接嵌入内核的通用数据结构。&lt;/p&gt;
&lt;h3 id="21-定时器控制块-nd_timer_t"&gt;2.1 定时器控制块 (&lt;code&gt;nd_timer_t&lt;/code&gt;)&lt;/h3&gt;
&lt;p&gt;定义于 &lt;code&gt;include/nd_def.h&lt;/code&gt;，该结构体包含以下关键成员：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;struct rb_node node&lt;/code&gt;&lt;/strong&gt;：红黑树节点，用于将定时器挂载到内核的全局定时器树上。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;nd_uint64_t expire_time&lt;/code&gt;&lt;/strong&gt;：绝对到期时间。内核统一将用户设置的相对超时时间转换为系统启动以来的绝对时间戳（Ticks 或微秒），以此作为红黑树排序的键值（Key）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;nd_timer_type_t type&lt;/code&gt;&lt;/strong&gt;：定时器类型，支持单次触发（&lt;code&gt;ND_TIMER_TYPE_ONE_SHOT&lt;/code&gt;）和周期触发（&lt;code&gt;ND_TIMER_TYPE_PERIODIC&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;回调机制&lt;/strong&gt;：包含函数指针 &lt;code&gt;callback&lt;/code&gt; 和参数 &lt;code&gt;arg&lt;/code&gt;，在定时器到期时执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="22-全局容器-rbtree_root"&gt;2.2 全局容器 (&lt;code&gt;rbtree_root&lt;/code&gt;)&lt;/h3&gt;
&lt;p&gt;内核维护一个静态全局变量 &lt;code&gt;rbtree_root&lt;/code&gt;（定义于 &lt;code&gt;kernel/nd_timer.c&lt;/code&gt;）。所有活动的定时器都驻留在这棵红黑树中。
使用红黑树的优势在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;查找最优&lt;/strong&gt;：获取最早到期的定时器（即树的最左节点 &lt;code&gt;rb_first&lt;/code&gt;）的时间复杂度极低。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作稳定&lt;/strong&gt;：插入和删除定时器的时间复杂度为 ，避免了传统双向链表在长列表下的遍历开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="3-运行模式详解"&gt;3. 运行模式详解&lt;/h2&gt;
&lt;p&gt;系统通过宏 &lt;code&gt;ND_CFG_TICKLESS&lt;/code&gt; 进行编译期配置，决定底层时钟驱动机制。&lt;/p&gt;
&lt;h3 id="31-tick-模式"&gt;3.1 Tick 模式&lt;/h3&gt;
&lt;p&gt;当 &lt;code&gt;ND_CFG_TICKLESS&lt;/code&gt; 为 0 时，系统工作在固定节拍模式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;时基驱动&lt;/strong&gt;：依赖硬件的周期性中断（如 SysTick）。在 &lt;code&gt;arch/arm/m33/port.c&lt;/code&gt; 中，Systick 被配置为以 &lt;code&gt;ND_TICKS_PER_SEC&lt;/code&gt; 的频率产生中断。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理流程&lt;/strong&gt;：
每次 Systick 中断触发 &lt;code&gt;isr_systick&lt;/code&gt;，进而调用 &lt;code&gt;nd_timer_process()&lt;/code&gt;。内核通过 &lt;code&gt;nd_hw_tick_get_current()&lt;/code&gt; 获取当前 Tick 计数，并检查红黑树最左节点是否到期。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：实现简单，但存在空闲时的无效中断开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="32-tickless-模式"&gt;3.2 Tickless 模式&lt;/h3&gt;
&lt;p&gt;当 &lt;code&gt;ND_CFG_TICKLESS&lt;/code&gt; 为 1 时，系统启用高精度动态定时模式。&lt;/p&gt;</description></item><item><title>哈希表</title><link>https://human-mean.github.io/posts/c%E8%AF%AD%E8%A8%80/%E5%93%88%E5%B8%8C%E8%A1%A8/</link><pubDate>Tue, 03 Feb 2026 00:00:00 +0000</pubDate><guid>https://human-mean.github.io/posts/c%E8%AF%AD%E8%A8%80/%E5%93%88%E5%B8%8C%E8%A1%A8/</guid><description>&lt;h3 id="哈希表是什么"&gt;哈希表是什么&lt;/h3&gt;
&lt;p&gt;哈希表通过建立键 &lt;code&gt;key&lt;/code&gt; 与值 &lt;code&gt;value&lt;/code&gt; 之间的映射，实现高效的元素查询，只需要输入一个&lt;code&gt;key&lt;/code&gt;就能获得对应值的value。　&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;哈希表与链表、数组的时间复杂度比较：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;数组&lt;/th&gt;
&lt;th&gt;链表&lt;/th&gt;
&lt;th&gt;哈希表&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;查找元素&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;添加元素&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;删除元素&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(n)&lt;/td&gt;
&lt;td&gt;O(1)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="哈希函数"&gt;哈希函数&lt;/h3&gt;
&lt;p&gt;一个&lt;strong&gt;把数据转换成数组下标&lt;/strong&gt;的规则，只有两个要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;同样的输入，永远得到同样的输出&lt;/li&gt;
&lt;li&gt;输出范围在 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;size-1&lt;/code&gt; 之间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;输入一个key，我们可以通过哈希函数获得key值对应键值的存储位置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;哈希函数的计算步骤：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.通过一个哈希算法&lt;code&gt;hash()&lt;/code&gt;得到哈希值。
2.将哈希值的数组长度&lt;code&gt;capacity&lt;/code&gt;取模，从而获取对应的&lt;code&gt;index&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;index = hash(key) % capacity&lt;/code&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;因为哈希函数可能算出很大的数，但数组下标是有限的。取模可以把任意大的数压缩到 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;capacity-1&lt;/code&gt; 的范围内。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id="哈希冲突与扩容"&gt;哈希冲突与扩容&lt;/h3&gt;
&lt;p&gt;哈希函数的作用是将所有 &lt;code&gt;key&lt;/code&gt; 构成的输入空间映射到数组所有索引构成的输出空间，而输入空间往往远大于输出空间。因此&lt;strong&gt;理论上一定存在多个输入对应相同输出的情况&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;7 % 10 = 7
17 % 10 = 7
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;哈希表容量越大，输出相同的可能性就越低，通过&lt;em&gt;扩容哈希表&lt;/em&gt;可以减少&lt;em&gt;哈希冲突&lt;/em&gt;&lt;/p&gt;</description></item><item><title/><link>https://human-mean.github.io/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://human-mean.github.io/readme/</guid><description>&lt;p&gt;#Init&lt;/p&gt;</description></item></channel></rss>